/******** DO NOT EDIT THIS FILE ********/
#ifndef _JOB_H
#define _JOB_H
#include <stdbool.h>
#include <unistd.h>
#include "sim_config.h"

/* 
 * JOB_STR_SIZE - the size of the string representation of a job. The length
 * of the string is JOB_STR_SIZE - 1
 */
#define JOB_STR_SIZE 69

/* JOB_STR_FMT - string format for the string representation of a job */
#define JOB_STR_FMT "pid:%07d,id:%05u,pri:%05u,label:%31s"

/* A string of PAD characters of length 31 (MAX_NAME_SIZE - 1) */
#define PAD_STRING "*******************************"

/* 
 * Definition of struct job - for entry on a job queue and for logging.
 *
 * Fields:
 * pid - the process id of the producer that created the job. Process ids
 *      should be unique for a given host.
 * id - the job id. Job ids are generated locally by the job producer process 
 *      and can be made unique for that producer process. By definition, the
 *      id field is unsigned and, therefore, cannot be negative.
 * priority - the assigned priority level for a job. The priority level is 
 *      assigned by the producer of the job with 1 being the highest priority
 *      level and values greater than 1 being progressively lower. That is 
 *      priorities have the following relationship:
 *      1 (high) > 2 > 3 ... > n 
 *      A priority of 0 is considered unused/invalid for the purposes of 
 *      priority ordering. A priority of 0 is for initialisation of a job that
 *      is not yet used for priority ordering. See pri_jobqueue.h for the 
 *      significance of priority level 0.
 *      By definition, the priority field is unsigned and, therefore, cannot be
 *      negative.
 * label - a character array of MAX_NAME_SIZE size to hold an 
 *      application-specific string label of length exactly MAX_NAME_SIZE - 1.
 * 
 * The combination of job.pid and job.id can be used to ensure globally unique  
 * jobs for a given host. That is, a pid uniquely identifies a process and a 
 * producer can ensure that the job ids it generates are unique. Uniqueness 
 * is imposed by applications using a job and not by the job functions 
 * specified in this header file.
 * 
 * The functions:
 *      job_new(pid_t pid, unsigned int id, unsigned int priority, 
 *          const char* label)
 *      job_copy(job_t* src, job_t* dst)
 *      job_init(job_t* job)
 *      job_is_equal(job_t* j1, job_t* j2)
 *      job_set(job_t* job, pid_t pid, unsigned int id, unsigned int priority,
 *          const char* label)
 *      job_to_str(job_t* job, char* str)
 *      str_to_job(char* str, job_t* job)
 *      job_delete(job_t* job)
 * provide the operations on a job_t to create, set and initialise a job, 
 * to copy from one job to another, to compare two jobs, to convert a job to
 * and from the string representation defined by JOB_STR_FMT, and to deallocate 
 * memory allocated by job_new.
 * 
 * job_new, job_copy, job_init, job_set, job_to_str and str_to_job functions 
 * all guarantee that the label field will be a string of length 
 * MAX_NAME_SIZE - 1. 
 * An initialised job will have the PAD_STRING for its label, which is also 
 * used to represent an empty label.
 *
 * Note:
 * job_new dynamically allocates a job and sets its fields to the values 
 * provided by its parameters. If you do not wish to create a job on the
 * heap, simply declare a job_t variable (for example on the stack) 
 * and set its field values separately, e.g.:
 *      job_t job;
 *      job_t* jptr = job_set(&job, 1, 0, 2, "joblabel");
 *
 * See also:
 * pri_jobqueue.h - for the interpretation of jobs in priority queueing
 *
 * Type aliasing means that job_t can be used as an alias for "struct job".
 */
typedef struct job {
    pid_t pid;
    unsigned int id;
    unsigned int priority;
    char label[MAX_NAME_SIZE];
} job_t;

/*
 * job_new(pid_t pid, unsigned int id, unsigned int priority, const char* label)
 * 
 * Creates a new (dynamically allocated) job struct with the given producer
 * process id, job id, priority and label.
 * 
 * The label parameter can be any application-specific string.
 * If the given label is less than length MAX_NAME_SIZE - 1, then the label
 * field of the job is padded to length MAX_NAME_SIZE - 1 with '*' characters.
 * If the given label string is longer than MAX_NAME_SIZE - 1, then the label
 * field of the job is truncated to exactly length  MAX_NAME_SIZE - 1. 
 * Padding or truncation ensure that the label stored with a job is exactly
 * length MAX_NAME_SIZE - 1 (and that the memory required for the label is 
 * fixed at MAX_NAME_SIZE, including the string's nul terminator). 
 * As noted in the description of the job_t struct, other functions in this
 * library guarantee this property of the label field.
 * 
 * If the label parameter is the empty string or is NULL, the label field
 * of the job will be the PAD_STRING defined in this header file (a label 
 * of all '*' characters of length MAX_NAME_SIZE - 1).
 *
 * Usage:
 *      pid_t pid = getpid();   // use system call getpid to get proces id 
 *      job_t* job = job_new(pid, 1, 2, "newjob");
 *                      // creates new job with given pid, id of 1, 
 *                      // priority 2 and label "newjob", which will be padded 
 *                      // to length MAX_NAME_SIZE - 1
 *      ...                         
 *      ...
 *      job_delete(job);    // delete this instance of the job struct
 *
 * Note, in the above usage example, padding of "newjob" results in the label
 * field: "newjob*************************"
 * 
 * Parameters:
 * pid - the id of the process creating the job (typically, this is the system 
 *      allocated process id that can be obtained using getpid)
 * id - an id for the job generated by the calling process
 * priority - the priority level for the job, where 0 is unused priority, 1 
 *      is the highest priority and values greater than 1 are successively 
 *      lower priorities.
 * label - the  application-specific label for the job.
 *
 * Return:
 * On success: a new non-NULL pointer to a dynamically allocated job struct.
 *      The job_new function guarantees that the label field of the job struct
 *      is a string of length exactly MAX_NAME_SIZE - 1, padded with '*'
 *      characters if necessary. If the label parameter is the empty string or
 *      NULL, the  stored label field will be the PAD_STRING (all '*'s). 
 *      Use job_delete to free memory allocated for the job struct.  
 * On failure: NULL, and errno is set as specified in Errors.
 *
 * Errors:
 * If the call fails, the NULL pointer will be returned. errno is set as 
 * specified by system library functions used to implement the function (see
 * below).
 * 
 * See also:
 * man page for malloc
 * sim_config.h - for specification of the maximum name/label size:
 * MAX_NAME_SIZE 
 */
job_t* job_new(pid_t pid, unsigned int id, unsigned int priority, 
    const char* label);

/*
 * job_copy(job_t* src, job_t* dst)
 * 
 * Copy from job src to job dst. Assuming the pointers src and dst are 
 * distinct, after copying, src and dst jobs will be distinct objects in memory
 * that are semantically equal as specified by the job_is_equal comparison. 
 * That is, the fields of the jobs pointed to by src and dst will be equal. 
 * A pointer to the copy is returned. 
 *
 * Combinations of src and dst pointer values are dealt with as follows:
 *      1. If src is NULL, the function returns NULL. 
 *      2. If src and dst pointers are identical, i.e. point to the same 
 *         object in memory, a job pointer is returned without any copying.
 *      3. If dst is NULL, a new job is dynamically allocated, the job pointed
 *         to by src is copied to the new job and a pointer to the new job is 
 *         returned. 
 *      4. If dst is not NULL and is not identical to src, the job pointed to by 
 *         src is copied to the job pointed to by dst and the dst pointer is 
 *         returned.
 *
 * In effect, in all cases, a pointer to the job copied to is returned (albeit
 * the pointer may be NULL).
 *
 * The properties of the label field are preserved by this function. That is,
 * the copied job's label field will be a string of length exactly 
 * MAX_NAME_SIZE - 1.
 *
 * Parameters:
 * src - a non-NULL pointer to a job to copy from. If the length of the src
 *      label is not exactly MAX_NAME_SIZE - 1 nothing will be copied and 
 *      NULL is returned
 * dst - the address of the job to copy to or NULL if a new copy is to be
 *      dynamically allocated 
 *
 * Return:
 * On success: a pointer to the copied object (the dst pointer). If dst is 
 *      NULL, a new, dynamically allocated copy of src is created.
 * On failure: NULL, and errno is set as specified in Errors. 
 *
 * Errors:
 * If the call fails, the NULL pointer will be returned.  In particular, 
 * NULL is returned if length of src->label is not MAX_NAME_SIZE - 1.
 * errno is set as specified for job_new.
 */
job_t* job_copy(job_t* src, job_t* dst);

/* 
 * job_init(job_t* job)
 * 
 * If job is not NULL, set the fields of the job pointed to by the job
 * parameter to the following values:
 *      job->pid set to 0
 *      job->id set to 0
 *      job->priority set to 0
 *      job->label set to the PAD_STRING
 * 
 * If job is NULL, this function has no effect.
 *
 * Parameters:
 * job - pointer to the job to initialise
 */
void job_init(job_t* job);

/*
 * job_is_equal(job_t* j1, job_t* j2)
 * 
 * Tests whether the two jobs, j1 and j2, are equal. The jobs are considered 
 * equal if each of their fields is equal
 *
 * Usage:
 *      job_t* j1 = job_new(1, 2, 1, "label1"};
 *      job_t* j2 = job_new(1, 2, 1, "label1"};
 *      job_t* j3 = job_new(1, 3, 3, "label1"};
 *      job_t* j4 = job_new(1, 3, 4, "label2"};
 *      job_t* j5 = job_new(2, 3, 5, "label2"};
 *
 *      bool b1 = job_is_equal(j1, j2); // true
 *      bool b2 = job_is_equal(j2, j3); // false
 *      bool b3 = job_is_equal(j3, j4); // false
 *      bool b4 = job_is_equal(j4, j5); // false
 *
 * Parameters:
 * j1 - pointer to first job to compare
 * j2 - pointer to second job to compare
 *
 * Return:
 * True if j1 and j2 are equal: j1->pid == j2->pid and j1->pid == j2->pid and 
 * j1->priority == j2->priority and the job labels are equal according to string
 * comparison, false otherwise.
 * Two identical pointers, including two NULL pointers are considered equal.
 */
bool job_is_equal(job_t* j1, job_t* j2);
 
/*
 * job_set(job_t* job, pid_t pid, unsigned int id, unsigned int priority, 
 *         const char* label)
 * 
 * Set the given non-null job with the values for the given pid, id, priority
 * and label. The label is copied to the given job's label field. Calling this 
 * function sets all fields of a job.
 *
 * The properties of the label field are preserved by this function. That is,
 * the job's label field will be a string of length exactly MAX_NAME_SIZE - 1.
 * 
 * Parameters:
 * job - a non-NULL pointer to the job to update
 * pid - the value to set the job process id to
 * id - the value to set the job id to
 * priority - the value to set the job priority to
 * label - the label to use to set the job. The label field of the job
 *      will start with the given label and be padded or truncated to 
 *      string length MAX_NAME_SIZE - 1 as described for job_new
 *
 * Return:
 * On success: the job pointer is returned. If job is NULL, this function has
 * no effect and the NULL pointer is returned.
 *
 * Note: this function does not dynamically allocate memory
 */
job_t* job_set(job_t* job, pid_t pid, unsigned int id, unsigned int priority,
    const char* label);

/*
 * job_to_str(job_t* job, char* str)
 * 
 * Convert the given job to its string representation of size exactly
 * JOB_STR_SIZE and format specified by JOB_STR_FMT.
 * For example, a job with pid 1, id 2, priority 3 and label 
 * "newjob*************************" will have the following string 
 * representation:
 *  "pid:0000001,id:00002,pri:00003,label:newjob*************************"
 *
 * Parameters:
 * job - a non-NULL pointer to the job to create a string representation for. 
 *      If the length of the job label is not exactly MAX_NAME_SIZE - 1 
 *      there is no conversion to string of the job and NULL is returned.
 * str - a char* pointer to a buffer large enough to hold the string 
 *      representation. If str is NUll, a buffer of the size JOB_STR_SIZE is 
 *      dynamically allocated.
 *
 * Return:
 * On success: a pointer to the string representation is returned (if str is 
 * not NULL, the returned pointer has the same value as the str parameter).
 * If str is NULL, a pointer to a new, dynamically allocated character buffer
 * containing the string representation is returned.
 * On failure: the NULL pointer is returned.
 * 
 * Errors:
 * If the call fails, the NULL pointer will be returned.  In particular, 
 * NULL is returned if length of job->label is not MAX_NAME_SIZE - 1.
 * If str is NULL, the function may fail because of a failure of dynamic 
 * allocation and return NULL.
 */
char* job_to_str(job_t* job, char* str);

/*
 * str_to_job(char* str, job_t* job)
 * 
 * Convert the given str that represents a job as specified by JOB_STR_FMT
 * to a job. For example, if str is:
 *  "pid:0000001,id:00002,pri:00003,label:newjob*************************"
 *
 * it will be converted to a job with pid 1, id 2, priority 3 and label 
 * "newjob*************************".
 *
 * If job is NULL, the memory for the job is dynamically allocated.
 * If str is NULL or not in the format specified by JOB_STR_FMT then this 
 * function will return NULL and any dynamically allocated memory will be 
 * deallocated. In particular, the function returns NULL if str is not length
 * JOB_STR_SIZE - 1 or if the label component of the resulting job is not length
 * MAX_NAME_SIZE - 1.
 *
 * Parameters:
 * str - a non-NULL pointer to a well-formed string representation of a job. 
 *      If str is NULL or is not the correct length, no conversion to a job
 *      is attempted and NULL is returned.
 * job - a pointer to a job to update with the field values of the str
 *      representation of a job. If job is NULL, a new job is dynamically 
 *      allocated for conversion of the string representation to a job.
 *
 * Return:
 * On success: a pointer to the job represented by the given string is returned
 * (which will a pointer with the same value as the job parameter if job is 
 * not NULL). If job is NULL, a pointer to a new, dynamically allocated job
 * corresponding to the string representation is returned.
 * On failure: the NULL pointer is returned.
 * 
 * Errors:
 * If the call fails, the NULL pointer will be returned.  In particular, 
 * NULL is returned if str is not in the correct format (e.g. is an invalid
 * length, or scanning for the representation of the fields of a job fails, 
 * or the resulting job label is an invalid length).
 * If job is NULL, the function may fail because of a failure of dynamic
 * allocation and return NULL.
 */
job_t* str_to_job(char* str, job_t* job);

/*
 * job_delete(job_t* job);
 * 
 * Delete a job struct that has been dynamically allocated by job_new.
 *
 * If job is NULL this function has no effect.
 *
 * Parameters:
 * job - a pointer to a job struct allocated by job_new. 
 *
 * Errors: it is an error to pass a pointer to a job that has not been 
 * dynamically allocated and this will cause program termination.
 */
void job_delete(job_t* job);

#endif