/******** DO NOT EDIT THIS FILE ********/

#ifndef _IPC_JOBQUEUE_H
#define _IPC_JOBQUEUE_H
#include <stdbool.h>
#include "pri_jobqueue.h"
#include "ipc.h"

/* 
 * Introduction
 * 
 * This header file defines an ipc_jobqueue type and the functions that 
 * operate on the queue (its interface):
 *      ipc_jobqueue_new(proc_t* proc);
 *      ipc_jobqueue_dequeue(ipc_jobqueue_t* ijq, job_t* dst);
 *      ipc_jobqueue_enqueue(ipc_jobqueue_t* ijq, job_t* job);
 *      ipc_jobqueue_is_empty(ipc_jobqueue_t* ijq);
 *      ipc_jobqueue_is_full(ipc_jobqueue_t* ijq);
 *      ipc_jobqueue_peek(ipc_jobqueue_t* ijq, job_t* dst);
 *      ipc_jobqueue_size(ipc_jobqueue_t* ijq);
 *      ipc_jobqueue_space(ipc_jobqueue_t* ijq);
 *      ipc_jobqueue_delete(ipc_jobqueue_t* ijq, job_t* dst);
 *
 * These are direct counterparts to pri_jobqueue functions (see pri_jobqueue.h). 
 * This is because, except for ipc_jobqueue_new and ipc_jobqueue_delete, 
 * each ipc_jobqueue function is a wrapper for the corresponding pri_jobqueue
 * function. That is, ipc_jobqueue_dequeue calls pri_jobqueue_dequeue,
 * ipc_jobqueue_enqueue calls pri_jobqueue_dequeue etc
 *
 * The main difference between a pri_jobqueue and an ipc_jobqueue is that a 
 * pri_jobqueue is allocated in the address space of a single
 * process, whereas an ipc_jobqueue is a wrapper for a pri_jobqueue that is
 * allocated in an area of shared memory that is set up as part of ipc object
 * creation and can be mapped to address spaces of multiple processes. 
 * That is, a pri_jobqueue is private to a single process, whereas ipc_jobqueue
 * wraps a pri_jobqueue that can be accessed by multiple processes. If one
 * process changes the shared queue then other processes that share it will see
 * the change.
 *
 * Another difference between an ipc_jobqueue and a pri_jobqueue is that, for 
 * simulation purposes, in each ipc_jobqueue function (except new and delete), 
 * a critical work delay is injected. This is done by calling 
 * do_critical_work with the proc field of the ipc_jobqueue object.
 *
 * At application level, usage of a pri_jobqueue and an ipc_jobqueue are almost
 * identical. The ipc_jobqueue abstracts away from shared memory setup etc.
 * It is trivial to modify an application using a pri_jobqueue to use an 
 * ipc_jobqueue.
 *
 * IMPORTANT:
 * Only operate on an ipc_jobqueue using the functions defined in 
 * this file. Using an ipc_jobqueue in any other way can result in undefined 
 * and erroneous behaviour.
 *
 * See pri_pri_jobqueue.h for details of pri_jobqueue operations.
 * See proc.h for the do_critical_work function.
 */
 
/* 
 * Type alias defining the ipc_jobqueue_t type as an alias for ipc_t.
 *
 * This means that the object used for the underlying queue (a pri_jobqueue) is 
 * allocated in shared memory and accessible via the addr field of an  
 * ipc_t object.
 *
 * See: ipc.h
 */
typedef ipc_t ipc_jobqueue_t;

/*
 * ipc_jobqueue_new(proc_t* proc)
 * 
 * Creates a new ipc_jobqueue (allocating resources for the queue).
 *
 * The ipc_jobqueue type is an alias for an ipc object where the addr 
 * field is a pri_jobqueue in shared memory.
 * 
 * Parameters:
 * proc - the non-null descriptor of a process sharing this queue
 *
 * Return:
 * On success: a pointer to a well-formed ipc object that encapsulates the 
 * queue in shared memory. If proc is the init process, the underlying 
 * pri_jobqueue is initialised.
 * On failure: NULL, and errno is set as specified in Errors.
 *
 * Errors:
 * If the call fails, the NULL pointer will be returned and errno will be 
 * set as follows:
 *      EINVAL - invalid argument if proc is NULL
 *      Other values as specified by the system library functions used to
 *      implement the function (see ipc_new in ipc.h)
 *
 * See also:
 * proc.h - for a description of the proc type
 * ipc.h - for the ipc type for which ipq_jobqueue_t is an alias
 */
ipc_jobqueue_t* ipc_jobqueue_new(proc_t* proc);

/*
 * ipc_jobqueue_dequeue(ipc_jobqueue_t* ijq, job_t* dst)
 *
 * This is a wrapper for pri_jobqueue_dequeue.
 *
 * See the specification of pri_jobqueue_dequeue in pri_jobqueue.h.
 *
 * In particular, if the ijq parameter is NULL this function has the 
 * same behaviour as the corresponding pri_jobqueue function and 
 * no critical work is simulated.
 */
job_t* ipc_jobqueue_dequeue(ipc_jobqueue_t* ijq, job_t* dst);

/*
 * ipc_jobqueue_enqueue(ipc_jobqueue_t* ijq, job-t* job)
 *
 * This is a wrapper for pri_jobqueue_enqueue.
 *
 * See the specification of pri_jobqueue_enqueue in pri_jobqueue.h.
 *
 * In particular, if the ijq parameter is NULL this function has the 
 * same behaviour as the corresponding pri_jobqueue function and 
 * no critical work is simulated.
 */
void ipc_jobqueue_enqueue(ipc_jobqueue_t* ijq, job_t* job);

/*
 * ipc_jobqueue_is_empty(ipc_jobqueue_t* ijq)
 *
 * This is a wrapper for pri_jobqueue_is_empty.
 *
 * See the specification of pri_jobqueue_is_empty in pri_jobqueue.h.
 *
 * In particular, if the ijq parameter is NULL this function has the 
 * same behaviour as the corresponding pri_jobqueue function and no critical
 * work is simulated.
 */
bool ipc_jobqueue_is_empty(ipc_jobqueue_t* ijq);

/*
 * ipc_jobqueue_is_full(ipc_jobqueue_t* ijq)
 *
 * This is a wrapper for pri_jobqueue_is_full.
 *
 * See the specification of pri_jobqueue_is_full in pri_jobqueue.h.
 *
 * In particular, if the ijq parameter is NULL this function has the 
 * same behaviour as the corresponding pri_jobqueue function and no critical
 * work is simulated.
 */
bool ipc_jobqueue_is_full(ipc_jobqueue_t* ijq);

/*
 * ipc_jobqueue_peek(ipc_jobqueue_t* ijq, job_t* dst)
 *
 * This is a wrapper for pri_jobqueue_peekhead.
 *
 * See the specification of pri_jobqueue_peekhead in pri_jobqueue.h.
 *
 * In particular, if the ijq parameter is NULL this function has the 
 * same behaviour as the corresponding pri_jobqueue function and no critical
 * work is simulated.
 */
job_t* ipc_jobqueue_peek(ipc_jobqueue_t* ijq, job_t* dst);

/*
 * ipc_jobqueue_size(ipc_jobqueue_t* ijq)
 *
 * This is a wrapper for pri_jobqueue_size.
 *
 * See the specification of pri_jobqueue_size in pri_jobqueue.h.
 *
 * In particular, if the ijq parameter is NULL this function has the 
 * same behaviour as the corresponding pri_jobqueue function and no critical
 * work is simulated.
 */
int ipc_jobqueue_size(ipc_jobqueue_t* ijq);

/*
 * ipc_jobqueue_space(ipc_jobqueue_t* ijq)
 *
 * This is a wrapper for pri_jobqueue_space.
 *
 * See the specification of pri_jobqueue_space in pri_jobqueue.h.
 *
 * In particular, if the ijq parameter is NULL this function has the 
 * same behaviour as the corresponding pri_jobqueue function and no critical
 * work is simulated.
 */
int ipc_jobqueue_space(ipc_jobqueue_t* ijq);

/*
 * ipc_jobqueue_delete(ipc_jobqueue_t* ijq)
 * 
 * Deletes a ipc_jobqueue, deallocating resources associated with the queue.
 * 
 * Parameters:
 * ijq - a non-null pointer to the ijq to delete
 *
 * Return:
 * There is no return value for the function. If ijq is not NULL and the call 
 * succeeds, resources associated with the queue have been freed. If ijq is 
 * NULL this function has no effect.
 *
 * Errors:
 * Various errors with access to any underlying shared memory object may occur
 * in which case the process is likely to terminate with a memory error.
 */
void ipc_jobqueue_delete(ipc_jobqueue_t* ijq);

#endif