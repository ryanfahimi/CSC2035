/******** DO NOT EDIT THIS FILE ********/
#ifndef _PRI_jobqueue_H
#define _PRI_jobqueue_H
#include <stddef.h>
#include <stdbool.h>
#include "sim_config.h"
#include "job.h"

#define JOB_BUFFER_SIZE 128     // the size of the jobs buffer used by a queue

/* 
 * Introduction
 *
 * This header defines a pri_jobqueue struct (pri_jobqueue_t) and associated
 * functions that together provide a priority of queue of jobs. The queue uses
 * a fixed sized array of job structs as a buffer (see the jobs field of the 
 * pri_jobqueue_t). The size of the buffer is defined by JOB_BUFFER_SIZE. That 
 * is, queue is full when all JOB_BUFFER_SIZE slots of the jobs array are 
 * in use with a valid job.
 *
 * PRIORITY QUEUING
 *
 * A priority queue means that jobs are dequeued in priority order - removing
 * the highest priority job first. A job's priority level is defined by its 
 * priority field. As stated in job.h, 0 is an unused priority level (see the
 * validity of jobs note below), 1 is the highest priority, 2 is next highest
 * priority level and so on. Priority levels are unsigned (i.e. there are no
 * negative priorities).
 *
 * The definition of ordering between priority levels means the following:
 *      - If there are two jobs in the queue (j1 and j2) and j1.priority is 1
 *        and j2.priority is 2, then j1 will be dequeued first. 
 *      - if there are two jobs in the queue (j1 and j2) and j1.priority is the 
 *        same as j2.priority, then the jobs will be dequeued in first-in, 
 *        first-out (FIFO) order. That is, if j2 was enqueued first, it will
 *        be dequeued first and if j1 was enqueued first, it will be 
 *        dequeued first.
 *
 * The semantics of priority queueing do not mean that jobs must be stored in
 * the  queue's buffer in priority order (e.g. with the highest priority job in 
 * slot 0, the next highest in slot 1 and so on). Jobs may be stored in 
 * priority order, or they may, for example, be stored in FIFO order, or in some 
 * other order. The priority queueing constraint simply means that jobs must be
 * dequeued in priority order.
 *
 * VALIDITY OF JOBS AND QUEUE STATE
 * 
 * A job in the priority queue is considered valid and available for dequeuing
 * if it has a priority level >= 1. Other slots of the queue's jobs buffer can
 * have initialised but unused jobs (i.e. with priority level 0). Those slots 
 * of the array are considered empty and available for jobs to be enqueued.
 * 
 *
 * The pri_jobqueue_t (alias for struct pri_jobqueue) encapsulates the state 
 * of the queue: buffer size, current size (number of valid jobs on the queue), 
 * and the buffer of jobs.
 *
 * The functions:
 *      pri_jobqueue_new()
 *      pri_jobqueue_init(pri_jobqueue_t* pjq)
 *      pri_jobqueue_dequeue(pri_jobqueue_t* pjq, job_t* dst)
 *      pri_jobqueue_enqueue(pri_jobqueue_t* pjq, job_t* dst)
 *      pri_jobqueue_is_empty(pri_jobqueue_t* pjq)
 *      pri_jobqueue_is_full(pri_jobqueue_t* pjq)
 *      pri_jobqueue_peek(pri_jobqueue_t* pjq, job_t* dst)
 *      pri_jobqueue_size(pri_jobqueue_t* pjq)
 *      pri_jobqueue_space(pri_jobqueue_t* pjq)
 *      pri_jobqueue_delete(pri_jobqueue_t* pjq)
 * provide the operations on a pri_jobqueue_t to create and initialise it, 
 * to remove jobs (dequeue) in priority order, to to add jobs (enqueue), 
 * to test its state (empty, full, peek at highest priority job in the queue, 
 * size and space), and to deallocate resources associated with the queue.
 *
 * Together the functions above maintain the integrity of a job queue
 * for single process access.
 *
 * IMPORTANT NOTES
 * 1. Only operate on a pri_jobqueue using the functions defined in 
 * this file. Using a pri_jobqueue in any other way can result in undefined 
 * and erroneous behaviour.
 * 2. pri_jobqueue_new both dynamically allocates a pri_jobqueue on the heap
 * and initialises the queue. If you do not wish to create the queue on the
 * heap, simply declare a pri_jobqueue_t variable (for example on the stack) 
 * and pass a pointer to it to pri_jobqueue_init to initialise the queue. For
 * example:
 *      pri_jobqueue_t pq;
 *      pri_jobqueue_init(&pq);
 */

/* 
 * Definition of struct pri_jobqueue that provides the state necessary for a
 * priority job queue. 
 *
 * Type alias:
 * A struct pri_jobqueue can also be referred to as pri_jobqueue_t
 *
 * Fields:
 * buf_size - the size of the job buffer
 * jobs - the fixed sized buffer of job descriptions (job_t types) 
 * size - the number of jobs in the queue (not the size of the buffer)
 *
 * Note fields of the struct should only be accessed in the implementation 
 * file pri_jobqueue.c. Use pri_jobqueue functions to operate on a 
 * pri_jobqueue struct.
 *
 * See also:
 * job.h - for information about the job descriptor type (job_t).
 *
 * Type aliasing means that pri_jobqueue_t can be used as an alias for 
 * "struct pri_jobqueue".
 */
typedef struct pri_jobqueue {
    int buf_size;
    int size;
    job_t jobs[JOB_BUFFER_SIZE];
} pri_jobqueue_t;

/*
 * pri_jobqueue_new()
 *
 * Dynamically allocates and initialise a pri_jobqueue. The returned queue is 
 * in an initial state defined by the function pri_jobqueue_init that means 
 * that the queue is empty and every slot in the queue is unused (its job is in 
 * an initialised/unused state).
 *
 * Usage:
 *      pri_jobqueue_t* pjq = pri_jobqueue_new();   // allocate a new job queue
 *      ...                          
 *      ...
 *      pri_jobqueue_delete(pjq);           // delete the queue and release
 *                                          // resources associated with it
 *
 * Return:
 * On success: a new non-null pointer to a dynamically allocated pri_jobqueue.
 *      Use pri_jobqueue_delete to free memory allocated to the pri_jobqueue.
 * On failure: NULL, and errno is set as specified in Errors.
 *
 * Errors:
 * If the call fails, the NULL pointer will be returned and errno will be 
 * set as specified by system library dynamic memory allocation functions.
 * 
 * Note:
 * It is possible to allocate a pri_jobqueue on the stack or as a global 
 * or static variable of type pri_jobqueue_t. In this case, do not use 
 * pri_jobqueue_new to create the queue. Just declare a pri_jobqueue_t variable
 * and pass a pointer to the pri_jobqueue_t to pri_jobqueue_init to initialise
 * the queue. For example:
 *      pri_jobqueue_t pq;
 *      pri_jobqueue_init(&pq);
 *      
 * See also:
 * pri_jobqueue_init - for a description of initialisation of a pri_jobqueue
 * job.h - for a description of the job type
 * man pages for malloc
 */
pri_jobqueue_t* pri_jobqueue_new();

/*
 * pri_jobqueue_init(pri_jobqueue_t* pjq)
 *
 * Initialise a pri_jobqueue as follows:
 *      buf_size to JOB_BUFFER_SIZE
 *      size to 0
 *      each job in the buffer to an initial state defined by job_init 
 *      (see job.h)
 *
 * pri_jobqueue_init is a utility function to either set up a new queue in an 
 * initialised state or to empty an existing queue. That is, after calling 
 * pri_jobqueue_init, the queue will be empty and each job slot in the queue
 * will represent and initialised/unused job. pri_jobqueue_new ensures 
 * the queue it returns is initialised. Other queues e.g. declared on the 
 * stack or in shared memory (see ipc_pri_jobqueue) can be passed to 
 * pri_jobqueue_init to ensure initialisation. 
 * 
 * Calling pri_jobqueue_init on a queue that is in use will empty the queue.
 * That is, the function can be used to both initialise and re-initialise a
 * queue.
 *
 * Calling a pri_jobqueue_init with a NULL queue will cause a memory error.
 *
 * Usage:
 *      pri_jobqueue_t* pjq = ...   // create a pri_jobqueue by some means
 *      pri_jobqueue_init(pjq);     // initialise the pri_jobqueue
 *
 * Parameters:
 * pjq - a non-null pointer to a pri_jobqueue to initialise
 *
 * Errors:
 * If pjq is NULL a memory error will occur and the calling process will 
 * terminate. It is the responsibility of the programmer calling the function
 * to ensure that pjq is not NULL.
 */
void pri_jobqueue_init(pri_jobqueue_t* pjq);

/* 
 * pri_jobqueue_dequeue(pri_jobqueue_t* pjq, job_t* dst)
 *
 * If the queue is not empty, dequeues the job with the highest priority.
 * See the introduction to this header file for the definition of highest 
 * priority and semantics of priority queueing.
 *
 * If dst is not NULL, the dequeued job is copied to the job pointed to by dst.
 * If dst is NULL, the dequeued job is copied to a new, dynamically allocated
 * job. A  pointer to the copy is returned. 
 * The state of the queue is updated such that the number of jobs on the queue
 * (the queue size) is decremented by 1 and an empty slot in the buffer results
 * from dequeuing (a slot in the queue's buffer is initialised and, 
 * therefore, indicated to be empty as a result of dequeuing a job).
 * That is, dequeueing a job copies the job and removes it from the queue 
 * (updating the size property of the queue and the state of the queue's 
 * buffer).
 * 
 * If the queue is empty, the function returns NULL. Calling dequeue on an 
 * empty queue has no effect on the state of the queue. Similarly, this 
 * function has no effect if pjq is NULL.
 * 
 * The user of this function can avoid the return of a NULL pointer by 
 * checking that the queue is not empty before calling dequeue.
 *
 * The returned job will have a valid priority level as defined for jobs in 
 * job.h.
 *
 * Usage:
 *      pri_jobqueue_t* pjq = pri_jobqueue_new(); 
 *      job_t dst;   
 *      ...
 *      ...
 *      // dequeue jobs as long as the queue is not empty, copying each 
 *      // dequeued job to the local variable dst:
 *      while (!pri_jobqueue_is_empty(pjq)) {     
 *          job_t* j = pri_jobqueue_dequeue(pjq, &dst); // j will point to dst
 *          ...
 *          ...
 *      }
 *      ...
 *      ...
 *      pri_jobqueue_delete(pjq); 
 * 
 *      // alternative approach with dynamic allocation of the copy of
 *      // dequeued job
 *      pri_jobqueue_t* pjq = pri_jobqueue_new(); 
 *      ...
 *      ...
 *      // dequeue jobs as long as the queue is not empty, copying each 
 *      // dequeued job to a new, dynamically allocated job
 *      while (!pri_jobqueue_is_empty(pjq)) {     
 *          job_t* j = pri_jobqueue_dequeue(pjq, NULL); // j points to a new job
 *          ...
 *          ...
 *          job_delete(j);  // necessary because of dynamic allocation of j
 *      }
 *      ...
 *      ...
 *      pri_jobqueue_delete(pjq); 
 *
 * Parameters:
 * pjq - a non-null pointer to a pri_jobqueue
 * dst - a pointer to the job to copy to, which may be NULL 
 *
 * Return:
 * A pointer to a copy of the job that was the highest priority job on 
 * the queue or, if the queue is empty, the NULL pointer.
 * If the dst paremeter is not NULL, the value of the returned pointer is the
 * same as the value of dst. If dst is NULL, a new job is dynamically allocated
 * and the highest priority job is copied to the new job and the return 
 * value is a pointer to the new job.
 * If pjq is NULL, this function has no effect and the NULL pointer is returned.
 *
 * Important note:
 * If the queue was not empty, after execution of this function, the 
 * size of the queue is decremented by 1 and jobs in empty slots in the queue
 * are in the initialised state.
 *
 * See also:
 * job.h - for description of the job type and job functions
 */
job_t* pri_jobqueue_dequeue(pri_jobqueue_t* pjq, job_t* dst);

/*
 * pri_jobqueue_enqueue(pri_jobqueue_t* pjq, job_t* job)
 *
 * If the queue is not full, enqueues the given job on the given queue.
 * The job pointed to by the parameter passed to the function is copied
 * to the queue.
 *
 * If the queue pjq is full, this function has no effect on the state of the 
 * the queue. If pjq or job pointers are NULL, this function has
 * no effect. If job has an invalid priority as defined in job.h, the job is 
 * not queued and this function has not effect.
 *
 * Important note:
 * This function gives no indication that the queue is full. It silently
 * fails if the queue is full. It is therefore the application 
 * programmer's responsibility to check whether the queue is full 
 * before calling this function.
 *
 * Usage:
 *      pri_jobqueue_t* pjq = pri_jobqueue_new();
 *      job_t job;                          // local job variable
 *      ...
 *      ...
 *      // enqueue jobs as long as the queue is not full
 *      while (!pri_jobqueue_is_full(pjq)) {  
 *          job_t* j = job_set(&job, ...); // set fields of local job   
 *          pri_jobqueue_enqueue(pjq, j);  
 *          ...
 *          ...
 *      }
 *      ...
 *      ...
 *      pri_jobqueue_delete(pjq);  
 *
 *      // alternative approach with dynamic allocation of the job to 
 *      // enqueue
 *      pri_jobqueue_t* pjq = pri_jobqueue_new();    
 *      ...
 *      ...
 *      // enqueue jobs as long as the queue is not full
 *      while (!pri_jobqueue_is_full(pjq)) {  
 *          job_t* j = job_new(...);    // dynamically allocate and set a job    
 *          pri_jobqueue_enqueue(pjq, j);  
 *          job_delete(j);              // delete job after enqueuing, a copy
 *          ...                         // is on the queue
 *          ...
 *          ...
 *      }
 *      ...
 *      ...
 *      pri_jobqueue_delete(pjq);  
 *
 * Parameters:
 * pjq - a non-null pointer to a pri_jobqueue
 * job - a non-null pointer to a job to copy to the queue
 *
 * See also:
 * job.h - for description of the job type and job functions
 */
void pri_jobqueue_enqueue(pri_jobqueue_t* pjq, job_t* job);

/*
 * pri_jobqueue_is_empty(pri_jobqueue_t* pjq)
 *
 * Returns true if the queue is empty, all slots are unused, and false
 * otherwise. A NULL queue is considered empty.
 *
 * Usage: see pri_jobqueue_dequeue
 *
 * Parameters:
 * pjq - a non-null pointer to a pri_jobqueue
 *
 * Return:
 * True if the queue is empty, false otherwise.
 * 
 * If pjq is NULL, the queue is considered empty. This guarantees the semantics
 * of pri_jobqueue_dequeue - ensuring that a job cannot be dequeued from a 
 * NULL queue.
 */
bool pri_jobqueue_is_empty(pri_jobqueue_t* pjq);

/* 
 * pri_jobqueue_is_full(pri_jobqueue_t* pjq)
 *
 * Returns true if the queue is full, the number of jobs in the queue has 
 * reached queue capacity, and false otherwise. A NULL queue is considered full.
 *
 * Usage: see pri_jobqueue_enqueue
 *
 * Parameters:
 * pjq - a non-null pointer to a pri_jobqueue
 *
 * Return:
 * True if the queue is full, false otherwise.
 *
 * If pjq is NULL, the queue is considered full. This guarantees the semantics
 * of pri_jobqueue_enqueue - ensuring that a job cannot be enqueued on a 
 * NULL queue.
 */
bool pri_jobqueue_is_full(pri_jobqueue_t* pjq);

/*
 * pri_jobqueue_peek(pri_jobqueue_t* pjq, job_t* dst)
 *
 * If the queue is not empty, copies the job with highest priority to the  
 * job pointed to by dst (if dst is not NULL). If dst is NULL, a new job is 
 * dynamically allocated and the highest priority job is copied to it.
 * Whether dst is NULL or not, the function returns a pointer to the copy.
 * If the queue is empty, the function returns the NULL pointer. The caller can
 * check whether the queue is empty prior to calling pri_jobqueue_peek to avoid
 * this.
 *
 * The returned pointer is to a copy of the highest priority job. It
 * is not the same job in memory as the job on the queue. That is, 
 * it is semantically equal to the job on the queue but not identical to it in
 * memory.
 *
 * This function does not change the state of the queue and, if changes are 
 * subsequently made to the copied job, the changes will not be reflected in 
 * the job on the queue.
 *
 * Usage:
 *      pri_jobqueue_t* pjq = pri_jobqueue_new();
 *      job_t dst;                  // local variable to copy to
 *      ...    
 *      ...
 *      if (!pri_jobqueue_is_empty(pjq))
 *          job_t* top_job = pri_jobqueue_peek(pjq, &dst);  
 *                                  // the queue's state is unchanged 
 *                                  // the original copy of top_job remains on
 *                                  // the queue. top_job points to the dst 
 *                                  // copy.
 *      ...
 *      ...
 *      pri_jobqueue_delete(pjq);  
 *
 *      // alternative approach with dynamic allocation of the job to copy to
 *      pri_jobqueue_t* pjq = pri_jobqueue_new();
 *      ...    
 *      ...
 *      if (!pri_jobqueue_is_empty(pjq))
 *          job_t* top_job = pri_jobqueue_peekhead(pjq, NULL);  
 *                                  // the queue's state is unchanged 
 *                                  // the original copy of top_job 
 *                                  // remains on the queue. top_job is
 *                                  // dynamically allocated because dst is 
 *                                  // NULL
 *      ...
 *      ...
 *      job_delete(top_job);
 *      pri_jobqueue_delete(pjq);  
 *
 * Parameters:
 * pjq - a non-null pointer to a pri_jobqueue
 * dst - a pointer to a job to copy to, which may be NULL
 *
 * Return:
 * A pointer to a copy of the highest priority job or NULL if the queue is empty
 * or pjq is NULL.
 *
 * See also:
 * job.h - for description of the job type and job functions
 */
job_t* pri_jobqueue_peek(pri_jobqueue_t* pjq, job_t* dst);

/*
 * pri_jobqueue_size(pri_jobqueue_t* pjq)
 *
 * Returns the size of the given queue (the number of valid jobs in the queue).
 * When a queue is empty, its size will be 0.
 *
 * Usage:
 *      pri_jobqueue_t* pjq = pri_jobqueue_new();
 *      ...
 *      ...
 *      int size = pri_jobqueue_size(pjq);      // get the queue's size
 *      printf("%d\n", size);                   // and print it to stdout                           
 *      ...
 *      ...
 *      pri_jobqueue_delete(pjq);
 *
 * Parameters:
 * pjq - a non-null pointer to a pri_jobqueue
 *
 * Return:
 * The size of the queue, which will be >= 0 if pjq is not NULL. If pjq is
 * NULL, the size will be 0. This preserves the semantics that a NULL queue 
 * is empty.
 */
int pri_jobqueue_size(pri_jobqueue_t* pjq);

/*
 * pri_jobqueue_space(pri_jobqueue_t* pjq)
 *
 * Returns available space in the given queue (the number of empty slots in
 * the queue's buffer). A queue's space is the total capacity of the queue's 
 * buffer less the size of the queue. When a queue is full, its space will 
 * be 0.
 * 
 * A slot in the queue's buffer is considered available if its job has a 
 * priority level of 0 (i.e is unused).
 *
 * Usage:
 *      pri_jobqueue_t* pjq = pri_jobqueue_new();
 *      ...
 *      ...
 *      int space = pri_jobqueue_space(pjq);     // get the queue's space
 *      printf("%d\n", space);                   // and print it to stdout                           
 *      ...
 *      ...
 *      pri_jobqueue_delete(pjq);
 *
 * Parameters:
 * pjq - a non-null pointer to a pri_jobqueue
 *
 * Return:
 * The space in the queue's buffer, which will be >= 0 if pjq is not NULL. 
 * If pjq is NULL, the space will be 0. This preserves the semantics that a 
 * NULL queue is full.
 */
int pri_jobqueue_space(pri_jobqueue_t* pjq);

/*
 * pri_jobqueue_delete(pri_jobqueue_t* pjq)
 * 
 * This function frees resources allocated by pri_jobqueue_new.
 *
 * Parameters:
 * pjq - a non-null pointer to the queue to delete
 *
 * Return:
 * There is no return value for the function. If pjq is not NULL and the call 
 * succeeds, the queue will be freed. If pjq is NULL this function has no
 * effect.
 */
void pri_jobqueue_delete(pri_jobqueue_t* pjq);

#endif