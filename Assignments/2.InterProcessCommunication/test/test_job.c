/******** DO NOT EDIT THIS FILE ********/
#include <stdio.h>
#include "test_job.h"
#include "../job.h"

#define TEST_LABELS 16
static char* label_in[TEST_LABELS] = {
    "",
    "a",
    "ab",
    "abc",
    "abcd",
    "abcdefghijklmnopqrstuvwxyz",
    "abcdefghijklmnopqrstuvwxyz0",
    "abcdefghijklmnopqrstuvwxyz01",
    "abcdefghijklmnopqrstuvwxyz012",
    "abcdefghijklmnopqrstuvwxyz0123",
    "abcdefghijklmnopqrstuvwxyz01234",
    "abcdefghijklmnopqrstuvwxyz012345",
    "abcdefghijklmnopqrstuvwxyz0123456",
    "abcdefghijklmnopqrstuvwxyz01234567",
    "abcdefghijklmnopqrstuvwxyz012345678",
    "abcdefghijklmnopqrstuvwxyz0123456789",
};

static int label_in_len[TEST_LABELS] = {
    0, 1, 2, 3, 4, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36
};

static char* expected_label[TEST_LABELS] = {
    "*******************************",
    "a******************************",
    "ab*****************************",
    "abc****************************",
    "abcd***************************",
    "abcdefghijklmnopqrstuvwxyz*****",
    "abcdefghijklmnopqrstuvwxyz0****",
    "abcdefghijklmnopqrstuvwxyz01***",
    "abcdefghijklmnopqrstuvwxyz012**",
    "abcdefghijklmnopqrstuvwxyz0123*",
    "abcdefghijklmnopqrstuvwxyz01234",
    "abcdefghijklmnopqrstuvwxyz01234",
    "abcdefghijklmnopqrstuvwxyz01234",
    "abcdefghijklmnopqrstuvwxyz01234",
    "abcdefghijklmnopqrstuvwxyz01234",
    "abcdefghijklmnopqrstuvwxyz01234",
};

static char* job_strings[TEST_LABELS] = {
    "pid:0000001,id:00000,pri:00001,label:*******************************",
    "pid:0000002,id:00001,pri:00002,label:a******************************",
    "pid:0000003,id:00002,pri:00003,label:ab*****************************",
    "pid:0000004,id:00003,pri:00004,label:abc****************************",
    "pid:0000005,id:00004,pri:00005,label:abcd***************************",
    "pid:0000006,id:00005,pri:00006,label:abcdefghijklmnopqrstuvwxyz*****",
    "pid:0000007,id:00006,pri:00007,label:abcdefghijklmnopqrstuvwxyz0****",
    "pid:0000008,id:00007,pri:00008,label:abcdefghijklmnopqrstuvwxyz01***",
    "pid:0000009,id:00008,pri:00009,label:abcdefghijklmnopqrstuvwxyz012**",
    "pid:0000010,id:00009,pri:00010,label:abcdefghijklmnopqrstuvwxyz0123*",
    "pid:0000011,id:00010,pri:00011,label:abcdefghijklmnopqrstuvwxyz01234",
    "pid:0000012,id:00011,pri:00012,label:abcdefghijklmnopqrstuvwxyz01234",
    "pid:0000013,id:00012,pri:00013,label:abcdefghijklmnopqrstuvwxyz01234",
    "pid:0000014,id:00013,pri:00014,label:abcdefghijklmnopqrstuvwxyz01234",
    "pid:0000015,id:00014,pri:00015,label:abcdefghijklmnopqrstuvwxyz01234",
    "pid:0000016,id:00015,pri:00016,label:abcdefghijklmnopqrstuvwxyz01234",
};

int main(int argc, char** argv) {
    return munit_suite_main(&suite, NULL, argc, argv);
}

static void set_test_job(job_t* job, pid_t pid, unsigned int id, 
    unsigned int priority, int label_idx) {
    job->pid = pid;
    job->id = id;
    job->priority = priority;
    
    char* label = label_idx < 0 ? PAD_STRING : expected_label[label_idx];
    
    (void) snprintf(job->label, MAX_NAME_SIZE, "%s", label);
}

static bool equal_jobs(job_t* j1, job_t* j2) {
    return j1->pid == j2->pid && j1->id == j2->id 
            && j1->priority == j2->priority
            && !strncmp(j1->label, j2->label, MAX_NAME_SIZE);
}

static void assert_init_job(job_t* job) {
    assert_not_null(job);
    assert_int(job->pid, ==, 0);
    assert_uint(job->id, ==, 0);
    assert_uint(job->priority, ==, 0);
    
    assert_int(strncmp(job->label, PAD_STRING, MAX_NAME_SIZE), ==, 0);
        
    assert_char(job->label[MAX_NAME_SIZE - 1], ==, '\0');
}

static void assert_job_equalities(job_t* j1, job_t* j2) {
    assert_true(job_is_equal(j1, j1));
    assert_true(job_is_equal(j2, j2));
    assert_true(job_is_equal(j1, j2));
    
    int n = munit_rand_int_range(1, 100);
    j1->pid = j1->pid + n;    
    assert_false(job_is_equal(j1, j2));    
    j1->pid = j1->pid - n;    
    assert_true(job_is_equal(j1, j2));
    
    n = munit_rand_int_range(1, 100);
    j1->id = j1->id + n;    
    assert_false(job_is_equal(j1, j2));    
    j1->id = j1->id - n;    
    assert_true(job_is_equal(j1, j2));
    
    n = munit_rand_int_range(1, 100);
    j1->priority = j1->priority + n;    
    assert_false(job_is_equal(j1, j2));    
    j1->priority = j1->priority - n;    
    assert_true(job_is_equal(j1, j2));

    n = munit_rand_int_range(1, MAX_NAME_SIZE - 1);
    j1->label[n-1] = j1->label[n-1] - n;
    assert_false(job_is_equal(j1, j2));
    j1->label[n-1] = j1->label[n-1] + n;
    assert_true(job_is_equal(j1, j2));
}

static void assert_valid_job(job_t* job, pid_t expected_pid, 
    unsigned int expected_id, unsigned int expected_priority, int label_idx) {
    assert_not_null(job);
    assert_int(job->pid, ==, expected_pid);
    assert_uint(job->id, ==, expected_id);
    assert_uint(job->priority, ==, expected_priority);
    
    assert_string_equal(job->label, expected_label[label_idx]);
    assert_int(strnlen(expected_label[label_idx], MAX_NAME_SIZE + 1), ==, 
        MAX_NAME_SIZE - 1);
    assert_int(strnlen(job->label, MAX_NAME_SIZE + 1), ==, MAX_NAME_SIZE - 1);
    assert_char(job->label[MAX_NAME_SIZE - 1], ==, '\0'); 
}

MunitResult test_job_new(const MunitParameter params[], void* fixture) {
    pid_t pid = getpid();
    
    for (int i = 0; i < TEST_LABELS; i++) {
        munit_logf(MUNIT_LOG_DEBUG, "test label %d: %s", i, label_in[i]);
        assert_int(strnlen(label_in[i], MAX_NAME_SIZE * 2), 
            ==, label_in_len[i]);
        job_t* job = job_new(pid, i, i + 1, label_in[i]);
        
        munit_logf(MUNIT_LOG_INFO, NCL_INFO_CALL_ITER_FMT, 
            __LINE__ + 1,  "assert_valid_job", i);
        assert_valid_job(job, pid, i, i + 1, i);
        
        free(job);
    }

    return MUNIT_OK;
}

MunitResult test_job_new_null(const MunitParameter params[], 
    void* fixture) {
    pid_t pid = getpid();
    job_t* job = job_new(pid, 1, 1, NULL);
    
    munit_logf(MUNIT_LOG_INFO, NCL_INFO_CALL_FMT, 
            __LINE__ + 1,  "assert_valid_job");
    assert_valid_job(job, pid, 1, 1, 0);

    free(job);
    
    return MUNIT_OK;
}

MunitResult test_job_copy_stack(const MunitParameter params[], void* fixture) {
    pid_t pid = getpid();
    job_t src;
    job_t dst;
    job_t pre_cpy_dst = {-1, 0, 1, "*"};
    
    for (int i = 0; i < TEST_LABELS; i++) {
        dst = pre_cpy_dst;
        set_test_job(&src, pid, i, i + 1, i);
        job_t* cpy = job_copy(&src, &dst);
        assert_ptr_equal(cpy, &dst);
        assert_ptr_equal(cpy->label, dst.label);
        assert_ptr_not_equal(cpy, &src);
        assert_ptr_not_equal(cpy->label, src.label);
        assert_false(equal_jobs(&src, &pre_cpy_dst));
        assert_true(equal_jobs(cpy, &src));
        assert_false(equal_jobs(cpy, &pre_cpy_dst));
        
        munit_logf(MUNIT_LOG_INFO, NCL_INFO_CALL_ITER_FMT, 
            __LINE__ + 1,  "assert_valid_job", i);
        assert_valid_job(cpy, pid, i, i + 1, i);
    }
    
    return MUNIT_OK;
}    

MunitResult test_job_copy_heap(const MunitParameter params[], void* fixture) {
    pid_t pid = getpid();
    job_t src;
    
    for (int i = 0; i < TEST_LABELS; i++) {
        set_test_job(&src, pid, i, i + 1, i);
        job_t* cpy = job_copy(&src, NULL);
        assert_ptr_not_equal(cpy, &src);
        assert_ptr_not_equal(cpy->label, src.label);
        
        munit_logf(MUNIT_LOG_INFO, NCL_INFO_CALL_ITER_FMT, 
            __LINE__ + 1,  "assert_valid_job", i);
        assert_valid_job(cpy, pid, i, i + 1, i);
        free(cpy);
    }
    
    return MUNIT_OK;
}

MunitResult test_job_copy_identity(const MunitParameter params[], 
    void* fixture) {
    pid_t pid = getpid();
    job_t src;
    
    for (int i = 0; i < TEST_LABELS; i++) {
        set_test_job(&src, pid, i, i + 1, i);
        job_t* cpy = job_copy(&src, &src);
        assert_ptr_equal(cpy, &src);

        munit_logf(MUNIT_LOG_INFO, NCL_INFO_CALL_ITER_FMT, 
            __LINE__ + 1,  "assert_valid_job", i);
        assert_valid_job(cpy, pid, i, i + 1, i);
    }
    
    job_t eq2src;
    
    for (int i = 0; i < TEST_LABELS; i++) {
        set_test_job(&src, pid, i, i + 1, i);
        set_test_job(&eq2src, pid, i, i + 1, i);
        assert_int(eq2src.pid, ==, src.pid);
        assert_int(eq2src.id, ==, src.id);
        assert_int(eq2src.priority, ==, src.priority);
        assert_string_equal(eq2src.label, src.label);
        
        job_t* cpy = job_copy(&src, &eq2src);
        
        assert_ptr_equal(cpy, &eq2src);
        assert_ptr_equal(cpy->label, eq2src.label);
        assert_ptr_not_equal(cpy, &src);
        assert_ptr_not_equal(cpy->label, src.label);
        
        munit_logf(MUNIT_LOG_INFO, NCL_INFO_CALL_ITER_FMT, 
            __LINE__ + 1,  "assert_valid_job", i);
        assert_valid_job(cpy, pid, i, i + 1, i);
    }      
    
    return MUNIT_OK;
}

MunitResult test_job_copy_badlabel_stack(const MunitParameter params[], 
    void* fixture) {
    job_t src;
    set_test_job(&src, 1, 0, 1, 1);  // label length is correct
    
    assert_int(strnlen(src.label, MAX_NAME_SIZE), ==, MAX_NAME_SIZE - 1);
    
    src.label[MAX_NAME_SIZE - 2] = '\0'; // short label
    
    assert_int(strnlen(src.label, MAX_NAME_SIZE), ==, MAX_NAME_SIZE - 2);

    job_t dst;
    
    assert_null(job_copy(&src, &dst));
    
    src.label[0] = '\0';    // empty label

    assert_int(strnlen(src.label, MAX_NAME_SIZE), ==, 0);
    
    assert_null(job_copy(&src, &dst));
    
    return MUNIT_OK;
}

MunitResult test_job_copy_badlabel_heap(const MunitParameter params[], 
    void* fixture) {
    job_t src;
    set_test_job(&src, 1, 0, 1, 1);  // label length is correct
    
    assert_int(strnlen(src.label, MAX_NAME_SIZE), ==, MAX_NAME_SIZE - 1);
    
    src.label[MAX_NAME_SIZE - 2] = '\0'; // short label

    assert_int(strnlen(src.label, MAX_NAME_SIZE), ==, MAX_NAME_SIZE - 2);

    assert_null(job_copy(&src, NULL)); // if result is not null, terminates
    
    src.label[0] = '\0';    // empty label

    assert_int(strnlen(src.label, MAX_NAME_SIZE), ==, 0);

    assert_null(job_copy(&src, NULL));
    
    // revert to good label
    src.label[0] = expected_label[1][0];
    src.label[MAX_NAME_SIZE - 2] = expected_label[1][MAX_NAME_SIZE - 2];
    
    job_t* cpy = job_copy(&src, NULL);
    
    assert_true(equal_jobs(&src, cpy));
    
    free(cpy);
    
    return MUNIT_OK;
}

MunitResult test_job_copy_null(const MunitParameter params[], 
    void* fixture) {
    job_t dst;

    assert_null(job_copy(NULL, &dst));
    
    assert_null(job_copy(NULL, NULL));
    
    return MUNIT_OK;
}

MunitResult test_job_init_stack(const MunitParameter params[], void* fixture) {
    pid_t pid = getpid();
    job_t job;

    job_init(&job);
    
    munit_logf(MUNIT_LOG_INFO, NCL_INFO_CALL_FMT, __LINE__ + 1,
        "assert_init_job");
    assert_init_job(&job);
    
    for (int i = 0; i < TEST_LABELS; i++) {
        set_test_job(&job, pid, i, i + 1, i);
        job_init(&job);
        
        munit_logf(MUNIT_LOG_INFO, NCL_INFO_CALL_ITER_FMT, 
            __LINE__ + 1,  "assert_init_job", i);
        assert_init_job(&job) ;
    }
    
    return MUNIT_OK;
}    

MunitResult test_job_init_heap(const MunitParameter params[], void* fixture) {
    pid_t pid = getpid();
    job_t* job = (job_t*) malloc(sizeof(job_t));

    job_init(job);    

    munit_logf(MUNIT_LOG_INFO, NCL_INFO_CALL_FMT, __LINE__ + 1,
        "assert_init_job");
    assert_init_job(job);
    
    free(job);
    
    for (int i = 0; i < TEST_LABELS; i++) {
        job = (job_t*) malloc(sizeof(job_t));
        set_test_job(job, pid, i, i + 1, i);
        job_init(job);

        munit_logf(MUNIT_LOG_INFO, NCL_INFO_CALL_ITER_FMT, 
            __LINE__ + 1,  "assert_init_job", i);
        assert_init_job(job);
        
        free(job);
    }
    
    return MUNIT_OK;
}    

MunitResult test_job_init_null(const MunitParameter params[], void* fixture) {
    job_init(NULL);
    
    return MUNIT_OK;
}

MunitResult test_job_is_equal(const MunitParameter params[], 
    void* fixture) { 
    job_t j1;
    job_t j2;
    
    for (int i = 0; i < TEST_LABELS; i++) {
        set_test_job(&j1, i + 1, i + 2, i + 3, i);
        set_test_job(&j2, i + 1, i + 2, i + 3, i);
        
        munit_logf(MUNIT_LOG_INFO, NCL_INFO_CALL_ITER_FMT, 
            __LINE__ + 1,  "assert_job_equalities", i);
            
        assert_job_equalities(&j1, &j2);
        
        munit_logf(MUNIT_LOG_INFO, NCL_INFO_CALL_ITER_FMT, 
            __LINE__ + 1,  "assert_job_equalities", i);
        assert_job_equalities(&j2, &j1);   
    }
    
    return MUNIT_OK;
}   

MunitResult test_job_is_equal_init(const MunitParameter params[], 
    void* fixture) { 
    job_t j1;
    job_t j2;
    
    set_test_job(&j1, 0, 0, 0, -1);
    set_test_job(&j2, 0, 0, 0, -1);

    munit_logf(MUNIT_LOG_INFO, NCL_INFO_CALL_ITER_FMT, 
            __LINE__ + 1,  "assert_init_job", 0);
    assert_init_job(&j1);
    assert_init_job(&j2);
    assert_true(job_is_equal(&j1, &j2));
    assert_true(job_is_equal(&j2, &j1));
        
    set_test_job(&j1, 0, 0, 0, 1);
    assert_false(job_is_equal(&j1, &j2));
    assert_false(job_is_equal(&j2, &j1));
    
    j1.pid = 0;
    j1.id = 0;
    j1.priority = 0;
    j1.label[0] = '*';
    
    assert_true(job_is_equal(&j1, &j2));
    assert_true(job_is_equal(&j2, &j1));

    return MUNIT_OK;
}   

MunitResult test_job_is_equal_null(const MunitParameter params[], 
    void* fixture) { 
    assert_true(job_is_equal(NULL, NULL));

    job_t job;
    
    for (int i = 0; i < TEST_LABELS; i++) {
        set_test_job(&job, i + 1, i + 2, i + 1, i);
        
        assert_false(job_is_equal(&job, NULL));
        assert_false(job_is_equal(NULL, &job));
    }     

    return MUNIT_OK;
}   

MunitResult test_job_set_stack(const MunitParameter params[], void* fixture) {
    pid_t pid = getpid();
    job_t job;
    
    for (int i = 0; i < TEST_LABELS; i++) {
        job_t* set_job = job_set(&job, pid, i, i + 1, label_in[i]);
        assert_ptr_equal(set_job, &job);

        munit_logf(MUNIT_LOG_INFO, NCL_INFO_CALL_ITER_FMT, 
            __LINE__ + 1,  "assert_valid_job", i);
        assert_valid_job(set_job, pid, i, i + 1, i);
    }
    
    return MUNIT_OK;
}    

MunitResult test_job_set_heap(const MunitParameter params[], void* fixture) {
    pid_t pid = getpid();
    
    for (int i = 0; i < TEST_LABELS; i++) {
        job_t* job = (job_t*) malloc(sizeof(job_t));
        job_t* set_job = job_set(job, pid, i, i + 1, label_in[i]);
        assert_ptr_equal(set_job, job);

        munit_logf(MUNIT_LOG_INFO, NCL_INFO_CALL_ITER_FMT, 
            __LINE__ + 1,  "assert_valid_job", i);
        assert_valid_job(set_job, pid, i, i + 1, i);
        
        free(job);
    }
    
    return MUNIT_OK;
}    

MunitResult test_job_set_null(const MunitParameter params[], void* fixture) {
    pid_t pid = getpid();

    assert_null(job_set(NULL, pid, 1, 1, label_in[0]));
    
    job_t job;
    job_t* set_job = job_set(&job, pid, 1, 1, NULL);
    assert_ptr_equal(set_job, &job);

    munit_logf(MUNIT_LOG_INFO, NCL_INFO_CALL_FMT, 
            __LINE__ + 1,  "assert_valid_job");
    assert_valid_job(set_job, pid, 1, 1, 0);
    
    return MUNIT_OK;
}

MunitResult test_job_to_str_stack(const MunitParameter params[], 
    void* fixture) {
    job_t job;
    char str[JOB_STR_SIZE];
    
    for (int i = 0; i < TEST_LABELS; i++) {
        set_test_job(&job, i + 1, i, i + 1, i);
        char* jobstr = job_to_str(&job, str);
        
        assert_string_equal(jobstr, job_strings[i]);
        assert_ptr_equal(jobstr, str);
    }

    return MUNIT_OK;

}

MunitResult test_job_to_str_heap(const MunitParameter params[], void* fixture) {
    job_t job;
    
    for (int i = 0; i < TEST_LABELS; i++) {
        set_test_job(&job, i + 1, i, i + 1, i);
        char* jobstr = job_to_str(&job, NULL);
        
        assert_string_equal(jobstr, job_strings[i]);
        
        free(jobstr);
    }

    return MUNIT_OK;

}

MunitResult test_job_to_str_err_stack(const MunitParameter params[], 
    void* fixture) {
    job_t job;
    char str[JOB_STR_SIZE];
    
    set_test_job(&job, 1, 0, 1, 1);
    assert_int(strnlen(job.label, MAX_NAME_SIZE), ==, MAX_NAME_SIZE - 1);

    job.label[MAX_NAME_SIZE - 2] = '\0';
    assert_int(strnlen(job.label, MAX_NAME_SIZE), ==, MAX_NAME_SIZE - 2);
    assert_null(job_to_str(&job, str));

    job.label[0] = '\0';
    assert_int(strnlen(job.label, MAX_NAME_SIZE), ==, 0);
    assert_null(job_to_str(&job, str));

    return MUNIT_OK;
}

MunitResult test_job_to_str_err_heap(const MunitParameter params[], 
    void* fixture) {
    job_t job;
    
    set_test_job(&job, 1, 0, 1, 0);
    assert_int(strnlen(job.label, MAX_NAME_SIZE), ==, MAX_NAME_SIZE - 1);

    job.label[MAX_NAME_SIZE - 2] = '\0';
    assert_int(strnlen(job.label, MAX_NAME_SIZE), ==, MAX_NAME_SIZE - 2);
    assert_null(job_to_str(&job, NULL));

    job.label[0] = '\0';
    assert_int(strnlen(job.label, MAX_NAME_SIZE), ==, 0);
    assert_null(job_to_str(&job, NULL));
    
    // good label
    job.label[0] = expected_label[0][0];
    job.label[MAX_NAME_SIZE - 2] = expected_label[0][MAX_NAME_SIZE - 2];
    assert_int(strnlen(job.label, MAX_NAME_SIZE), ==, MAX_NAME_SIZE - 1);
    
    char* str = job_to_str(&job, NULL);
    
    assert_string_equal(str, job_strings[0]);

    return MUNIT_OK;

}

MunitResult test_job_to_str_null(const MunitParameter params[], void* fixture) {
    char str[JOB_STR_SIZE];

    assert_null(job_to_str(NULL, str));

    return MUNIT_OK;
}

MunitResult test_str_to_job_stack(const MunitParameter params[], 
    void* fixture) {
    job_t expected_job;
    job_t job;
        
    for (int i = 0; i < TEST_LABELS; i++) {
        set_test_job(&expected_job, i + 1, i, i + 1, i);
        job_t* actual_job = str_to_job(job_strings[i], &job);
        
        assert_true(equal_jobs(actual_job, &expected_job));
        assert_int(strnlen(actual_job->label, MAX_NAME_SIZE), ==, 
            MAX_NAME_SIZE - 1);
        assert_ptr_equal(actual_job, &job);
    }
    
    return MUNIT_OK;
}

MunitResult test_str_to_job_heap(const MunitParameter params[], void* fixture) {
    job_t expected_job;
        
    for (int i = 0; i < TEST_LABELS; i++) {
        set_test_job(&expected_job, i + 1, i, i + 1, i);
        job_t* actual_job = str_to_job(job_strings[i], NULL);
        
        assert_true(equal_jobs(actual_job, &expected_job));
        assert_int(strnlen(actual_job->label, MAX_NAME_SIZE), ==, 
            MAX_NAME_SIZE - 1);
    }
    
    return MUNIT_OK;
}

MunitResult test_str_to_job_err_stack(const MunitParameter params[], 
    void* fixture) {
    job_t job;
    char str[JOB_STR_SIZE + 1];
    snprintf(str, JOB_STR_SIZE, "%s", job_strings[0]);
    
    str[JOB_STR_SIZE - 1] = '*';
    str[JOB_STR_SIZE] = '\0';
    
    assert_int(strnlen(str, JOB_STR_SIZE), ==, JOB_STR_SIZE);
    
    assert_null(str_to_job(str, &job));

    str[JOB_STR_SIZE - 2] = '\0';
    assert_int(strnlen(str, JOB_STR_SIZE), ==, JOB_STR_SIZE - 2);
    assert_null(str_to_job(str, &job));

    str[0] = '\0';
    assert_int(strnlen(str, JOB_STR_SIZE), ==, 0);
    assert_null(str_to_job(str, &job));
    
    snprintf(str, JOB_STR_SIZE, "%s", 
        "pid:0000001,id:00000,pri:00001,label:******");
        
    assert_null(str_to_job(str, &job));

    snprintf(str, JOB_STR_SIZE, "%s", "pid:0000001,id:00000,pri:00001");
    
    assert_null(str_to_job(str, &job));

    snprintf(str, JOB_STR_SIZE, "%s", "pid:0000001,id:00000");
    
    assert_null(str_to_job(str, &job));

    snprintf(str, JOB_STR_SIZE, "%s", "pid:0000001");
    
    assert_null(str_to_job(str, &job));

    snprintf(str, JOB_STR_SIZE, "%s",
        "pid:0000002-id:00001-pri:00002-label:a******************************");
        
    assert_null(str_to_job(str, &job));
    
    return MUNIT_OK;
}

MunitResult test_str_to_job_err_heap(const MunitParameter params[], 
    void* fixture) {
    char str[JOB_STR_SIZE + 1];
    snprintf(str, JOB_STR_SIZE, "%s", job_strings[0]);
    
    str[JOB_STR_SIZE - 1] = '*';
    str[JOB_STR_SIZE] = '\0';
    
    assert_int(strnlen(str, JOB_STR_SIZE), ==, JOB_STR_SIZE);
    
    assert_null(str_to_job(str, NULL));

    str[JOB_STR_SIZE - 2] = '\0';
    assert_int(strnlen(str, JOB_STR_SIZE), ==, JOB_STR_SIZE - 2);
    assert_null(str_to_job(str, NULL));

    str[0] = '\0';
    assert_int(strnlen(str, JOB_STR_SIZE), ==, 0);
    assert_null(str_to_job(str, NULL));
    
    snprintf(str, JOB_STR_SIZE, "%s", 
        "pid:0000001,id:00000,pri:00001,label:******");
        
    assert_null(str_to_job(str, NULL));

    snprintf(str, JOB_STR_SIZE, "%s", "pid:0000001,id:00000,pri:00001");
    
    assert_null(str_to_job(str, NULL));

    snprintf(str, JOB_STR_SIZE, "%s", "pid:0000001,id:00000");
    
    assert_null(str_to_job(str, NULL));

    snprintf(str, JOB_STR_SIZE, "%s", "pid:0000001");
    
    assert_null(str_to_job(str, NULL));

    snprintf(str, JOB_STR_SIZE, "%s",
        "pid:0000002-id:00001-pri:00002-label:a******************************");
        
    assert_int(strnlen(str, JOB_STR_SIZE), ==, JOB_STR_SIZE -1);
    assert_null(str_to_job(str, NULL));
    
    return MUNIT_OK;
}

MunitResult test_str_to_job_null(const MunitParameter params[], void* fixture) {
    job_t job; 
    
    assert_null(str_to_job(NULL, &job));

    return MUNIT_OK;
}


MunitResult test_job_delete(const MunitParameter params[], void* fixture) {
    job_t* job = (job_t*) malloc(sizeof(job_t));
    
    /* the following should just not cause errors */
    job_delete(job);
    
    /* check NULL OK */    
    job_delete(NULL);
 
    return MUNIT_OK;
}

