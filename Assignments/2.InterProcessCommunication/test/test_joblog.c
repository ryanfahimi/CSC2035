/******** DO NOT EDIT THIS FILE ********/
#include <stdio.h>
#include <errno.h>
#include "test_joblog.h"
#include "procs4tests.h"
#include "../joblog.h"

#define LOG_FILES 4
#define TEST_ENTRY_NUM 11
#define PRESERVE_LOG_OPT "--log-visible"
#define PRESERVE_LOG_SIZE 16

static char* log_fname[LOG_FILES] = {
    "out/bwait_cons0000000.txt",
    "out/bwait_prod0000001.txt",
    "out/bwait_cons0000002.txt",
    "out/bwait_prod0000003.txt"
};

static char* job_label[TEST_ENTRY_NUM] = {
    "*******************************",
    "a******************************",
    "ab*****************************",
    "abc****************************",
    "abcd***************************",
    "abcdefghijklmnopqrstuvwxyz*****",
    "abcdefghijklmnopqrstuvwxyz0****",
    "abcdefghijklmnopqrstuvwxyz01***",
    "abcdefghijklmnopqrstuvwxyz012**",
    "abcdefghijklmnopqrstuvwxyz0123*",
    "abcdefghijklmnopqrstuvwxyz01234",
};

int main(int argc, char** argv) {
    int preserve_logs = 0;
    
    for (int i = 0; i < argc; i++) {
        if (!strncmp(argv[i], PRESERVE_LOG_OPT, PRESERVE_LOG_SIZE)) {
            preserve_logs = 1;
            
            printf(
            "***************************************************************\n"
            "WARNING: the --log-visible option has been selected. Logs will\n"
            "be preserved in the out directory and test_joblog_delete will\n"
            "be a null test and have no effect. To run test_joblog_delete,\n"
            "run the test without the --log-visible option.\n"
            "***************************************************************\n"
            );
            break;
        }
    }
        
    return munit_suite_main(&suite, &preserve_logs, argc, argv);
}

void* test_setup(const MunitParameter params[], void* user_data) {
    proc_t* p = new_test_proc(91);
    p->is_init = true;
    
    joblog_init(p);
    
    proc_delete(p);
    
    errno = 0;

    return user_data;
}

void test_tear_down(void* fixture) {
    int* preserve_logs = (int*) fixture;
    
    if (!*preserve_logs) {
        for (int i = 0; i < LOG_FILES; i++)
            unlink(log_fname[i]);
    }
    
    errno = 0;
}

static void write_entries(pid_t cp_id, bool test_errno) {
    job_t job;
    
    for (int i = 0; i < TEST_ENTRY_NUM; i++) {
        int init_errno = errno;
        job.pid = cp_id % 2 ? cp_id : i + 1;
        job.id = i;
        job.priority = i + 1;
        (void) snprintf(job.label, MAX_NAME_SIZE, "%s", job_label[i]);
               
        proc_t* proc = new_test_proc(cp_id);
        
        joblog_write(proc, &job);
        
        if (test_errno) assert_int(errno, ==, init_errno);
                
        proc_delete(proc);
    }
}

static MunitResult test_cpid_joblog_write(pid_t cp_id) {
    errno = 0;
    write_entries(cp_id, false);
    
    FILE* lf = fopen(log_fname[cp_id], "r");
    
    if (!lf) 
        return MUNIT_FAIL;
    
    char actual[JOB_STR_SIZE];
    char expected[JOB_STR_SIZE];
    int i = 0;
    while (i < TEST_ENTRY_NUM && fgets(actual, JOB_STR_SIZE, lf)) {
        actual[JOB_STR_SIZE - 1] = '\0';
        
        munit_logf(MUNIT_LOG_DEBUG, "actual entry: %s", actual);
        
        (void) snprintf(expected, JOB_STR_SIZE, JOB_STR_FMT, 
            cp_id % 2 ? cp_id : i + 1, i, i + 1, job_label[i]);

        assert_string_equal(actual, expected);
        i++;
        fgetc(lf); // consume newline
    }
    
    assert_int(i, ==, TEST_ENTRY_NUM);
    
    fclose(lf);

    return MUNIT_OK;
}

MunitResult test_sequential_joblog_read(pid_t cp_id, job_t
    wjobs[TEST_ENTRY_NUM], bool dynamic_alloc, bool test_errno) {
    proc_t* proc = new_test_proc(cp_id);
    
    job_t local_job;
    job_t* job = dynamic_alloc ? NULL : &local_job;
    
    int i = 0;
    int init_errno = errno;
    
    job_t* rjob = NULL;
    while ((rjob = joblog_read(proc, i, job))) {
        
        munit_logf(MUNIT_LOG_DEBUG, 
            "Read entry %d: pid:%d,id:%u,pri:%u,%s", i, 
                rjob->pid, rjob->id, rjob->priority, rjob->label);
        
        assert_not_null(rjob);
        
        if (dynamic_alloc)
            assert_ptr_not_equal(rjob, &local_job);
        else
            assert_ptr_equal(rjob, &local_job);
            
        assert_int(rjob->pid, ==, wjobs[i].pid);
        assert_int(rjob->id, ==, wjobs[i].id);
        assert_int(rjob->priority, ==, wjobs[i].priority);
       
        assert_string_equal(rjob->label, wjobs[i].label);
        
        if (dynamic_alloc) free(rjob);
        i++;
        if (test_errno) assert_int(errno, ==, init_errno);
    }
    
    assert_int(i, ==, TEST_ENTRY_NUM);
    
    proc_delete(proc); 

    return MUNIT_OK;
}

MunitResult test_random_joblog_read(pid_t cp_id, job_t
    wjobs[TEST_ENTRY_NUM], bool dynamic_alloc, bool test_errno) {
    proc_t* proc = new_test_proc(cp_id);
    
    job_t local_job;
    job_t* job = dynamic_alloc ? NULL : &local_job;
    
    int i = 0;
    int init_errno = errno;
    
    while (i < (TEST_ENTRY_NUM * 2)) {
        int entry_num = munit_rand_int_range(0, TEST_ENTRY_NUM - 1);
        
        job_t* rjob = joblog_read(proc, entry_num, job);
        
        munit_logf(MUNIT_LOG_DEBUG, 
            "Read entry %d: pid:%d,id:%u,pri:%u,%s", entry_num, 
                rjob->pid, rjob->id, rjob->priority, rjob->label);
        
        assert_not_null(rjob);
        
        if (dynamic_alloc)
            assert_ptr_not_equal(rjob, &local_job);
        else
            assert_ptr_equal(rjob, &local_job);
        
        assert_int(rjob->pid, ==, wjobs[entry_num].pid);
        assert_int(rjob->id, ==, wjobs[entry_num].id);
        assert_int(rjob->priority, ==, wjobs[entry_num].priority);
       
        assert_string_equal(rjob->label, wjobs[entry_num].label);

        if (dynamic_alloc) free(rjob);
        i++;
        if (test_errno) assert_int(errno, ==, init_errno);
    }
    
    proc_delete(proc); 

    return MUNIT_OK;
}

static MunitResult test_cpid_joblog_read(pid_t cp_id, bool dynamic_alloc, 
    bool test_errno, bool sequential) {
    
    job_t wjobs[TEST_ENTRY_NUM];

    FILE* lf = fopen(log_fname[cp_id], "w");
    
    char jstr[JOB_STR_SIZE];
    
    if (!lf)
        return MUNIT_FAIL;
    
    for (int i = 0; i < TEST_ENTRY_NUM; i++) {
        // store job for read comparison
        wjobs[i].pid = cp_id % 2 ? cp_id : i + 1;
        wjobs[i].id = i;
        wjobs[i].priority = i + 1;
        (void) snprintf(wjobs[i].label, MAX_NAME_SIZE, "%s", job_label[i]);
        
        (void) snprintf(jstr, JOB_STR_SIZE, JOB_STR_FMT, wjobs[i].pid,
                wjobs[i].id, wjobs[i].priority, wjobs[i].label);
        
        munit_logf(MUNIT_LOG_DEBUG, "Writing job[%d]: %s", i, jstr);
        fprintf(lf, "%s\n", jstr);
    }
    
    fclose(lf);
    
    return sequential 
            ? test_sequential_joblog_read(cp_id, wjobs, dynamic_alloc,
                test_errno)
            : test_random_joblog_read(cp_id, wjobs, dynamic_alloc,
                test_errno);
}


MunitResult test_joblog_write_cpid0(const MunitParameter params[], 
    void* fixture) {
    return test_cpid_joblog_write(0);
}    

MunitResult test_joblog_write_cpid1(const MunitParameter params[], 
    void* fixture) {
    return test_cpid_joblog_write(1);
}    

MunitResult test_joblog_write_cpid2(const MunitParameter params[], 
    void* fixture) {
    return test_cpid_joblog_write(2);
}    

MunitResult test_joblog_write_cpid3(const MunitParameter params[], 
    void* fixture) {
    return test_cpid_joblog_write(3);
}    

MunitResult test_joblog_write_errno(const MunitParameter params[], 
    void* fixture) {
    errno = 0;
    write_entries(0, true); 
    
    return MUNIT_OK;
}    

MunitResult test_joblog_write_null(const MunitParameter params[], 
    void* fixture) {
    int init_errno = errno;
    
    job_t j;
    j.pid = 0;
    j.id = 0;
    j.priority = 0;
    (void) snprintf(j.label, MAX_NAME_SIZE, "%s", job_label[0]);
    
    joblog_write(NULL, &j);
    
    assert_int(errno, ==, init_errno);
    
    proc_t* proc = new_test_proc(98);
    
    joblog_write(proc, NULL);
    
    assert_int(errno, ==, init_errno);
    
    proc_delete(proc);

    return MUNIT_OK;
}

MunitResult test_joblog_read_cpid0(const MunitParameter params[],
    void* fixture) {
    return test_cpid_joblog_read(0, true, false, true);
}

MunitResult test_joblog_read_cpid1(const MunitParameter params[],
    void* fixture) {
    return test_cpid_joblog_read(1, true, false, true);
}

MunitResult test_joblog_read_cpid2(const MunitParameter params[],
    void* fixture) {
    return test_cpid_joblog_read(2, true, false, true);
}

MunitResult test_joblog_read_cpid3(const MunitParameter params[],
    void* fixture) {
    return test_cpid_joblog_read(3, true, false, true);
}

MunitResult test_joblog_read_stack(const MunitParameter params[],
    void* fixture) {
    return test_cpid_joblog_read(0, false, false, true);
}

MunitResult test_joblog_read_rand(const MunitParameter params[],
    void* fixture) {
    return test_cpid_joblog_read(0, true, false, false);
}

MunitResult test_joblog_read_errno(const MunitParameter params[],
    void* fixture) {
    return test_cpid_joblog_read(0, true, true, true);
}

MunitResult test_joblog_read_bounds(const MunitParameter params[],
    void* fixture) {
    proc_t* proc = new_test_proc(0);
    
    FILE* lf = fopen(log_fname[0], "w");
    
    if (!lf)
        return MUNIT_FAIL;
    
    char jstr[JOB_STR_SIZE];
    
    for (int i = 0; i < TEST_ENTRY_NUM; i++) {
        snprintf(jstr, JOB_STR_SIZE, JOB_STR_FMT, i, i + 1, i + 1,
            job_label[i]);     
        
        fprintf(lf, "%s\n", jstr);
    }
    
    fclose(lf);
    
    int init_errno = errno;
    job_t* job = joblog_read(proc, -1, NULL);

    assert_null(job);
    assert_int(errno, ==, init_errno);
    
    job = joblog_read(proc, TEST_ENTRY_NUM, NULL);

    assert_null(job);
    assert_int(errno, ==, init_errno);
    
    proc_delete(proc);

    return MUNIT_OK;
}

MunitResult test_joblog_read_null(const MunitParameter params[],
    void* fixture) {
    int init_errno = errno;
    
    job_t* x = joblog_read(NULL, 0, NULL);
    
    assert_null(x);
    assert_int(errno, ==, init_errno);
    
    proc_t* proc = new_test_proc(99);
    
    // no file should exist because none created
    x = joblog_read(proc, 0, NULL);
        
    assert_null(x);
    assert_int(errno, ==, init_errno);
    
    proc_delete(proc);
    
    return MUNIT_OK;
}

MunitResult test_joblog_delete(const MunitParameter params[],
    void* fixture) {
    int* preserve_logs = (int*) fixture;
    
    if (*preserve_logs)
        return MUNIT_OK;
    
    for (int i = 0; i < LOG_FILES; i++) {
        FILE* lf = fopen(log_fname[i], "w");
        fclose(lf);
        
        if (access(log_fname[i], F_OK) == -1) 
            return MUNIT_FAIL;
        
        proc_t* proc = new_test_proc(i);   
        int errno_init = errno;
        
        joblog_delete(proc);
        
        assert_int(errno, ==, errno_init);
        
        proc_delete(proc);
        
        assert_int(access(log_fname[i], F_OK), ==, -1);
        assert_int(errno, ==, ENOENT);  
    }
    
    errno = 0;
    
    return MUNIT_OK;
}

